<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Retro Hoops</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #d68b30;
}

#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
}

canvas {
    width: 100vw;
    height: 100vh;
    display: block;
}

#controls {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
}

.btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    text-align: center;
    line-height: 70px;
    font-weight: bold;
    color: white;
}

#shoot { background: red; }
#pass { background: blue; }
#steal { background: green; }
</style>
</head>
<body>

<div id="gameContainer">
    <canvas id="game"></canvas>

    <div id="controls">
        <div id="steal" class="btn">STEAL</div>
        <div style="display:flex; gap:20px;">
            <div id="pass" class="btn">PASS</div>
            <div id="shoot" class="btn">SHOOT</div>
        </div>
    </div>
</div>

    <script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

        function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

resizeCanvas();
window.addEventListener("resize", resizeCanvas);

let players = [];
let userPlayer = null;
let ball = { x: 0, y: 0, holder: null };
let score = 0;

class Player {
    constructor(x, y, team, matchupIndex) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.radius = 14;
        this.hasBall = false;
        this.matchupIndex = matchupIndex;
        this.speed = 2.5;
    }

    draw() {
        ctx.beginPath();
        ctx.fillStyle = this.team === "home" ? "white" : "black";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    moveToward(tx, ty, speedMultiplier = 1) {
        let dx = tx - this.x;
        let dy = ty - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 1) {
            this.x += dx / dist * this.speed * speedMultiplier;
            this.y += dy / dist * this.speed * speedMultiplier;
        }
    }
}

function createTeams() {
    for (let i = 0; i < 5; i++) {
        players.push(new Player(150, 100 + i*70, "home", i));
        players.push(new Player(750, 100 + i*70, "away", i));
    }

    userPlayer = players[0];
    userPlayer.hasBall = true;
    ball.holder = userPlayer;
}

function drawCourt() {
    ctx.fillStyle = "#d68b30";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "white";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
}

function distance(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
}

function updateDefense() {
    players.forEach(p => {
        if (p.team === "away") {
            let offensivePlayer = players.find(pl => pl.team === "home" && pl.matchupIndex === p.matchupIndex);

            if (offensivePlayer.hasBall) {
                // Tight defense on ball
                p.moveToward(offensivePlayer.x, offensivePlayer.y, 1.5);

                // AI steal chance
                if (distance(p, offensivePlayer) < 20 && Math.random() < 0.02) {
                    offensivePlayer.hasBall = false;
                    p.hasBall = true;
                    ball.holder = p;
                }

            } else {
                // Guard matchup
                p.moveToward(offensivePlayer.x + 20, offensivePlayer.y);
            }
        }
    });
}

function update() {
    drawCourt();
    updateDefense();

    players.forEach(p => p.draw());

    if (ball.holder) {
        ball.x = ball.holder.x;
        ball.y = ball.holder.y;
    }

    ctx.beginPath();
    ctx.fillStyle = "orange";
    ctx.arc(ball.x, ball.y, 7, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.fillText("Score: " + score, 20, 30);

    requestAnimationFrame(update);
}

canvas.addEventListener("touchmove", function(e){
    let rect = canvas.getBoundingClientRect();
    let touch = e.touches[0];
    let x = touch.clientX - rect.left;
    let y = touch.clientY - rect.top;
    userPlayer.moveToward(x, y);
});

document.getElementById("pass").ontouchstart = function() {
    let teammates = players.filter(p => p.team === "home" && p !== userPlayer);
    let next = teammates[Math.floor(Math.random()*teammates.length)];

    userPlayer.hasBall = false;
    next.hasBall = true;
    userPlayer = next;
    ball.holder = userPlayer;
};

document.getElementById("shoot").ontouchstart = function() {
    if (userPlayer.x > canvas.width - 120) {
        score += 2;
        resetPositions();
    }
};

document.getElementById("steal").ontouchstart = function() {
    players.forEach(p => {
        if (p.team === "away" && p.hasBall) {
            if (distance(p, userPlayer) < 25) {
                p.hasBall = false;
                userPlayer.hasBall = true;
                ball.holder = userPlayer;
            }
        }
    });
};

function resetPositions() {
    players = [];
    createTeams();
}

createTeams();
update();
</script>

</body>
</html>
